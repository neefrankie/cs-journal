---
title: "快速排序"
date: 2021-06-18T10:33:06+08:00
draft: true
---

## 数据结构与算法(Swift):快速排序

快速排序(quicksort)无疑是最流行的排序算法，因为在多数情况下，快速排序最快，所需时间是O(N*logN)。（仅针对内部或者内存排序，在磁盘文件中对数据排序，其他算法肯能更快。）快速排序由查尔斯·安东尼·理查德·霍尔(Charles Antony Richard Hoare)于1962年发现。

注：C.A.R. Hoare，英国计算机科学家，图灵奖得主，也是null的创造者--他称之为价值数十亿的错误。

要理解快速排序，应该熟悉上一节讲述的分区算法。快速排序把一个数组分成两个子数组，然后递归地调用自己，快速排序每一个子数组。不过，这个基本的方案还有一些细节需要我们处理。这涉及到选择基准值以及各种小分区的排序。我们先看核心的算法，稍后再看这些改进。

### 快速排序算法

基本的递归快速排序相当简单，例如：

如你所见，分成三个基本步骤：

1. 数组或子数组分期，分成左右两组，左侧是较小的键，右侧是较大键。
2. 调用自身来给左侧组排序。
3. 调用自身被右侧组排序。

分区之后，左侧子数组的元素都比右侧的元素小。如果继续给左侧子数组和右侧子数组分别排序，整个数组就排好序了。那莪如何给这些子数组排序呢？递归地调用自身。

`recQuickSort()`的参数决定了所要排序的数组（或子数组）的左右边界。该方法首先检查这个数组是否只有一个元素。如果是，按照定义，这个数组已经排好顺序，立刻返回。这是此处递归的基准。

如果该数组由两个或多个元素，算法调用`partitionIt()`方法给数组分区。该方法返回分区的索引：右侧子数组的左侧元素。分区索引标明了子数组之间的分界线。

数组分区后，`recQuickSort()`调用自己，一次用于数组的左侧部分，索引从`left`到`partition-1`，一次用于数组的右侧部分，从`partition+1`到`right`。注意，在两次递归调用中，都没有包括`partition`索引的数据元素。为什么呢？这个元素不需要排序吗？原因取决于如何选择基准值。

### 选择基准值

`partitionIt()`方法应该用什么做基准值？可以参考如下要点：

* 基准值应该是实际存在的数据元素的键值，这个元素称为基准。
* 大致上可以随机选择一个数据元素做基准。简单起见，我们可以总是选择需要分期的子数据最右侧的元素。
* 执行分区以后，如果基准值插入的位置在左右两侧子数据之间，那就是它的最终位置。

最后一点可能听上去不可能，但记住，因为记基准值的键被用于分割数组，在分区之后，左侧子数组的所有元素都小于基准，右侧子数组的所有制都大于基准。基准值从右侧开始，但如果它被放在了连个子数组之间，那就在正确的位置--也就是说，在最终的排序位置上。下图展示了这一结果，选择的记住只是36.

该图不太现实，因为你实际上无法像图中所示那样切割一个数组。那么如何把基准移动到正确的位置呢？

我们可以把右侧子数组中的所有元素都向右移动一格，为基准值让出空间。但是，这么做效率低而且没有必要。右侧子数组的所有元素虽然比基准值大，但尚未排序，所以还会在右侧子数组内部继续移动，但不会有影响这个子数组之外的元素。因为，为了简化插入基准值到恰当的位置，我们可以直接把基准值（36）与右侧子数组的最左侧元素（63）交换。交换后，基准值就放在了左右两侧子数组之间的前挡位置。63放在了最右端，但因为它依然在右侧组，分期未受影响。如下图所示。

当基准值被换到了分区位置，就是它的最终静止位置了。接下来所有的操作都发生在他的左侧或者右侧，但基准值本身不会再移动（实际上不会再访问）。

采用选择最右侧元素作为基准值的方案时，需要修改`partitionIt()`方法，把最右侧的元素从分区中排除，因为我们已经知道了分区过程完成后基准值应该放在哪里：在两个子数组的分割位置。此外，再分区过程完成后，我们需要把基准值从右侧换到分割位置。

### Swift实现

有趣的一点是，`partitionIt()`方法中，在第一个内部while循环中，我们能够移除测试是否达到了子数组末尾。为什么呢？因为我们选择了最右侧的元素作为基准值，如果`leftIndex`达到了子数组的末尾，由于一个数不会比它自身小，肯定会停下来。不过第二个while中依然需要检测`rightIndex`移动到了数组的开始。

因此，使用最右侧元素作为基准值并非完全随意的选择，这么做移除了一个不必要的测试，加算了代码执行。从其他位置选择基准值不会提供这一优势。