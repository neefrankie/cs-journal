---
title: "7 Recursion"
date: 2021-06-25T21:56:26+08:00
draft: true
---

## 汉诺塔(Towers of Hanoi)

汉诺塔是一个古老谜题。如下图所示，一些圆盘放在三根圆柱上。

每张圆盘直径不同，中间有孔，能放在圆柱上。所有的圆盘开始放在圆柱A上。谜题要求把圆柱A上的圆盘转移到圆柱C上。一次只能移动一个圆盘，圆盘不能放在比自己小的圆盘上。

![Towers of Hanoi](/static/algorithms/recursion-tower-of-hanoi.png)

据说印度某地有个古老的神话，一座遥远的庙宇中，有三座钻石镶嵌的塔，放着64个黄金圆盘，和尚们日夜操劳搬运圆盘。他们搬完之时，就是世界末日。不过，一旦你看到，即便区区64个圆盘，解谜所需时间之长，心中升起的惊恐也会消失。

### 移动子树

我们可以把塔A上初始以树形（或金字塔形）堆放的圆盘称为一棵“树”。在解决问题的过程中，你会发现会形成较小的树形对方的圆盘。我们称这些为子树。例如，如果你尝试搬运4个圆盘，会发现中间有个步骤会在塔B上形成一个三个圆盘的子树，如下图所示。

![A subtree on tower B](/static/algorithms/recursion-subtree-on-tower-b.png)

在解谜的过程中，这些子树会形成很多次。出现这种情况是因为，要把更大的圆盘从一个塔搬到另一个塔上，创建子树是唯一的途径：所有较小的圆盘都必须放在中间塔上，自然形成子树结构。

首先搬动圆盘到哪座塔上有个规则。如果要移动的子树上的圆盘数量是奇数，最上面的圆盘直接放到目标塔上。如果要移动的子树是偶数，最上面的圆盘应该先移动到中间塔上。

### 递归算法

汉诺塔的解法可以用子树的概念递归地表达。假设你要把源塔(S)上的所有圆盘搬运到目标塔(D)上。有座中间塔(I)可用。假设塔S上有圆盘n个。算法如下：

1. 从S移动最上面n-1个圆盘构成的子树到I。
2. 把剩下的（最大）的圆盘从S移到D。
3. 把子树从I移到D。

开始时，源塔是A，中间塔是B，目标塔是C。如下图所示。

![Recursive solution to towers puzzle](/static/algorithms/recursion-recursive-solution-to-towers-puzzle.png)

首先，圆盘1、2和3构成的子树被移动到中间塔B。然后最大的圆盘4被移到塔C。然后移动子树从B到C。

当然，这个方法没有解决如何把1、2和3构成的子树移动到塔B上，因为饿哦们不能一次移动整个子树，一次只能移动一个圆盘。移动三个圆盘的子树没那么容易，不过比移动4个圆盘容易。

事实上，把三个圆盘从A移到B可以使用同移动四个圆盘相同的三个步骤。即，把最上面两个圆盘组成的子树从A移动到中间塔C，然后第三个圆盘从A移动到B，最后把两个圆盘的子树从C移到B。

怎么把两个圆盘的子树从A移到C呢？把只有一个圆盘组成的子树从A移到B。这是基准条件：移动仅有的一个圆盘时，直接移动，没什么其他需要做的。然后把圆盘2从A移到C，圆盘1构成的子树放在它上面。