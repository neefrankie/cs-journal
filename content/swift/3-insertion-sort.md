---
title: "数据结构与算法(Swift)3：插入排序"
date: 2021-06-11T17:32:11+08:00
draft: true
---

多数时候，在初级排序算法中，插入排序(insertion sort)最好。插入排序执行时间仍为O(N²)，但大约比冒泡排序快一倍.正常情况下，比选择排序还快一些。通常用于更高级排序算法中的最后一步，如快速排序(quicksort)。

## 对棒球队员实行插入排序

开始插入排序前，先让棒球队队员按随机顺序排队。假设队列已经有一半排好了顺序，从流程的中间开始思考插入排序更容易。

### 不完全排序（partial sorting）

此刻，设想队列中间有个标记。标记左侧队员已经按照从左到右、从矮到高的顺序排好了队。不过，这些队员并不一定站在了最终位置，因为如果此前未排序的队员需要插入他们中间，他们仍需移动。

注意，冒泡排序和选择排序中不涉及局部排序。这两种算法中，在某个时刻，一组数据元素总是彻底排好了顺序。在插入排序中，一组元素并未完全排好顺序。

### 被标记的队员

被标记的队员右侧的所有队员，都尚未排序。

我们需要做的是，把被标记的队员，插入到完成部分排序一侧的恰当位置。不过，要这么做，必须把某些排好顺序的的队员向右侧移动，让出位置。要为移动提供空间，需要把被标记的队员从队列中移除。在程序中，这个数据元素保存在临时变量中。

现在我们移动已经排序的队员来让出空间。最高的队员挪到被标记队员的位置，次高的队员移到最高的队员位置，逐次移动。

这个移动过程什么时候停止？设想你和被标记的队员沿着队列向左走。在每个位置都把一个队员向右移动，同时还要比较被标记队员和被移动队员的身高。最后一名比被标记队员高的队员移动过去后，这一过程就停止了。最后一次移动空出来的位置可以插入被标记的队员，这个位置就是他的排序位置。

现在，部分排序组多了一个队员，未排序组少了一个队员。标记向右移动一个位置，又放在了未排序组最左侧的队员面前。重复这一过程，直到所有未排序的队员都被插入了部分排序组中的恰当位置。

## Swift实现

```swift
func insertionSort(arr: [Int]) -> [Int] {
    guard arr.count > 1 else {
        return arr
    }

    var sortedArray = arr

    for markerIndex in 1..<sortedArray.count {
        // Store marker
        let temp = sortedArray[markerIndex]
        // Start from marker, backward.
        var innerIndex = markerIndex;

        while innerIndex > 0 && sortedArray[innerIndex - 1] > temp {
            sortedArray[innerIndex] = sortedArray[innerIndex - 1]
            // Remember to move the index.
            innerIndex -= 1
        }

        sortedArray[innerIndex] = temp
    }

    return sortedArray
}

print(insertionSort(arr: [77, 99, 44, 55, 22, 88, 11, 00, 66, 33]))
```

## 插入排序的效率

这一算法需要多少次复制和排序？第一轮，最多比较一次。第二轮，最多比较两次。到最后一次最多比较N-1次。就是：

1 + 2 + 3 + ... + N-1 = N*(N-2)/2

不过，因为每一轮中，平均只需最大元素数量的一半参与比较就可以找到插入点，可以除以2：

N*(N-1)/4

复制的次数大约接近比较的次数。不过，复制不像交换那么耗时，所以，对于随机数据而言，插入算法比冒泡算法快一倍，比选择算法快。

对于已经排序或者几乎排好序的数据，插入算法表现更好。如果数据已经排好了顺序，`while`循环中的条件永远不是true，所以只剩下了简单的外部循环，执行N-1次。这种情况下，插入算法耗时O(N)。
