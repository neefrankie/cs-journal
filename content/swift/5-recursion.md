---
title: "数据结构与算法(Swift)5：递归-2"
date: 2021-06-24T15:40:01+08:00
draft: true
---

## 易位构词游戏（Anagram）

有些情况下，递归提供了解决问题的简捷方案。排列是以一定的顺序安排事物。假设你要列出特定单词的所有易位构词，也就是说原始单词中所有字母的可能排列，不管是否构成实际的英语单词。我们称之为一个单词的易位构词。例如，cat的易位构词会产生：

* cat
* cta
* atc
* act
* tca
* tac

试试找一些单词进行易位构词。你会发现，可能的组成的单词数量是字母总数的阶乘。3个字母可能组成6个词，4个字母可能组成24个单词，5个字母就是120，等等。（这里假设字母不重复，如果一个字母重复出现，可能组成的次会少。）

怎么写一个程序对单词易位构词？这里站是一个方法。假设单词有n个字母。

1. 对右侧的n-1个字母易位构词
2. 按序循环移动所有的n个字母
3. 这些步骤重复n次

按序循环移动单词是指把所有字母依次向左移动一个位置，最左侧的字母则“旋转”到最右侧，如下图所示

![Rotate a word](/static/algorithms/recursion-rotate-a-word.png)

单词旋转n次，就让每个字母都有机会排在单词的开始位置。被选中的字母占据第一个位置时，其余的字母进行易位构词。单词cat只有三个字母，旋转剩余的两个字母只需交换位置即可。序列如下所示。

![Anagramming the word cat](/static/algorithms/recursion-anagramming-the-word-cat.png)

注意，后两个字母必须旋转回初始位置才能旋转三个字母。这会产生序列cat、cta、cat。冗余的序列不予显示。

如何对最右侧的n-1个字母易位构词呢？调用自己。递归函数doAnagram()的唯一参数时易位构词的单词的大小。这个单词时完整单词最右侧的n个字母。每次doAnagram()调用自己，传递的的单词就比上一次少一个字母。

![The recursive doAnagram() method](/static/algorithms/recursion-doAnagram-method.png)

当被易位构词的单词只剩一个字母时，就触发基准条件。一个单词无法再重新排列。否则就对出第一个字母之后的其余字母易位构词，然后旋转整个单词。这两个动作执行n次，n是单词的长度。


