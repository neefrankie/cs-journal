---
title: "数据结构与算法(Swift)4：递归-1"
date: 2021-06-22T23:06:35+08:00
draft: true
---

## 递归

递归是一种编程技术，一个方法或函数可以调用自己。这种方式听起来奇怪，甚至像是一个灾难性的错误。但是，递归是编程中最有意思、最有效的编程技术。就像让你用自己的提靴带把自己拉起来一样，第一次看到递归，会觉得难以置信。然而，递归不仅能用，还为解决很多问题提供了独一无二的概念结构。

## 三角形数(triangular numbers)

据说，古希腊在毕达哥斯拉(Pythagoras，以毕达哥斯拉定理闻名，即勾股定理)手下工作的一群毕达哥斯拉学派数学家觉得，1、3、6、10、15、21...这一些列数字之间有着神秘的联系。你能找出下一个数字吗？

这一系列数字中的第n项等于n加上上一项的值。因此，第二项等于2加上第一项的值(即1)，得到3。第三项是3加上第二项的值，等于6，以此类推。

这一系列数字称为“三角形数”，因为这些数字可以可视化为三角形排列的物体，如下图所示。

![](/static/recursion/triangular-numbers.png)

### 使用循环找出第n项值

假设我们想要找出来这一系列数字中的第任意n项值，如第4项（值为10）。应该如何计算呢？上图可以看出，任意一项的值，可以把所有的垂直列中的方块相加得到。

对第4项而言，第一列有4个小方块，第二列有3个，以此类推。4+3+2+1等于10。

下述`triangle()`函数使用这种基于列的方法来找出一个三角形数。它把所有的列相加，从高度为n的列加到高度为1的列：


该函数循环n次，第一次把`n`加到`total`上，第二次加上`n-1`，一直加到1为止，n变为0时退出循环。

### 使用递归找出第n项值

循环方法看上去很直观，但还有其他方法来解决这个问题。第n项的值可以当作仅有两项之和，而不是全部的数字。这就是：

1. 第一列，即n；
2. 所有剩余列之和。

如果我们有办法找到所有剩余列之和，就能写出`triangular`方法，返回n项三角形数的值，如：

```swift
func triangle(n： Int) -> Int {
    return n + sumRemainingColumns(n)
}
```

但这里我们的收益是什么？看上去，写出`sumRemainingColumns()`函数和写出`triangle`一样难。

不过，n项的剩余列之和，与n-1项之和是一样的。所以，如果我们知道一个方法可以算出n项所有列之和，那么使用参数n-1调用这个方法，找出n项所有剩余列之和：

```swift
func triangle(n: Int) -> Int {
    return n + sumAllColumns(n - 1)
}
```

但是，仔细想想，`sumAllColumns()`方法做的正是`triangle()`做的事情：算出传入参数n的所有列之和。所以，为什么不直接使用`triangle()`方法呢？

```swift
func triangle(n: Int) -> Int {
    return n + triangle(n - 1)
}
```

一个函数可以调用自己或许让你感到惊奇，但为什么不能呢？函数调用是把控制转移到函数的开始。这种控制转移既可以出现在函数内部，也可以出现在函数外部。

这些方法就像击鼓传花。有人问我9个三角形数是多少。我知道答案是9加8个三角形数之和，于是我打电话给Harry，让他找出8个三角形数是多少。当我得到了回答，九八9机上他告诉我的数，这就是答案。

Harry知道8个三角形数是8加7个三角形数之和，于是他问Sally，7个三角形数是多少。这一过程持续下去，每个人把问题丢给下一个人。

这个传递过程什么时候结束？总有在某个时刻必须找出一个不需要问其他人就能得出的答案。否则，就会出现一条没有尽头的链条，每个人都在问其他人问题，就像算术版的庞氏骗局一样，永无休止。就`triangle()`而言，这意味着函数会没完没了第调用自己，知道程序崩溃。

要组织无穷回归，被要求找出第一个三角形数的人（即n等于1），不需要问任何人就必须知道，答案是1。没有更小的数需要问别人了，也不需要再加任何数了，于是传递到此为止。我们可以再`triangle()`中加一个条件：

```swift
func triangle(n: Int) -> Int {
    if (n == 1) {
        return n
    }
    return n + triangle(n - 1)
}
```

递归函数不需要进行递归调用即可返回的条件称为基准条件。每个递归函数必须有一个基准条件来防止无穷递归，这一点至关重要，否则会导致程序终止。

### 递归函数的特征

尽管`triangle()`函数很短，但它具有递归程序共有的关键特征：

* 调用自身
* 调用自己是，解决一个更小的的问题
* 这个问题的某个版本足够简单，程序不需要调用自己就可以解决并返回

递归函数每次调用自己时，问题就变小，表明问题变小了或者变容易了。当参数或者范围达到某个最小值时，某个条件被触发，函数不调用自己就返回。

### 递归效率高吗？

调用函数需要一定的开销。控制必须从调用点转移到函数的开头。此外，函数的参数和需要反蝴蝶地址必须推到内部对战堆栈上，这样函数才能访问参数值，知道从哪里返回。

以`triangle()`为例，因为这种开销，while循环方法比递归执行得更快。代价或许没那么大，但如果递归方法导致大量函数调用，消灭掉递归或许更好。

另一个低效之处是，在系统内部堆栈中存储中间参数和返回的值需要占用内存。如果数据量很大，可能引发问题，导致堆栈溢出。

通常使用递归是为了从概念上简化问题，而不是因为它本身效率高。

### 数学归纳

递归变成等同于数学归纳法。数学归纳法这种方式通过自身来定义某种事物。使用归纳法，我们可以用数学形式定义三角形数：

tri(n) = 1               如果 n = 1
tri(n) = n + tri(n - 1)  如果 n < 1

## 阶乘（factorial）