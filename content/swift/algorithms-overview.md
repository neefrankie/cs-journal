---
title: "数据结构与算法（Swift）：概述"
date: 2021-05-30T16:10:07+08:00
draft: true
---

## 1. 数据结构与算法的用途

**数据结构**指如何在计算机内存（有时是磁盘）中安排数据。数据结构包括数组、链表、堆栈、二分树和哈希表。**算法**则采用各种方式操纵这些结构中的数据，如搜索某个特定的数据元素、数据排序等。

## 2. 猜数字游戏

我们小时候可能玩过一个著名的猜数字游戏：别人心里想着一个1到100之间的数字，让你猜这个数字是什么。你说出一个数字，对方只能回答：

* 你猜的高了
* 你猜的低了
* 你猜对了

要想以最少的次数猜出来，应该总是从50开始猜起。如果对方说猜的数太低，那就可以推断出来目标数字在51到100之间，下一次应该猜75（51到100中间）；如果对方说太高了，就可以推测目标数字在1到49之间，下次则猜测25。

每次猜测都可以把可能的取值范围分半。最后就剩下的一个数字就是答案。

要找到这个数字，需要猜测的次数很少。如果采用线性查找，从1、2、3逐个开始，找到目标数字，平均需要猜测50次。用二分查找法，每次把取值范围缩小一半，所需猜测的次数少得多。下图显示了目标数字为33时，所需要的游戏回合。

表1

| 次数      | 猜测的数字  | 结果    | 可能的取值范围 |
| -------- | --------- | ------- | ----------- |
| 0        |           |         | 1-100       |
| 1        | 50        | 高      | 1-49        |
| 2        | 25        | 低      | 26-49       |
| 3        | 37        | 高      | 26-36       |
| 4        | 31        | 低      | 32-36       |
| 5        | 34        | 高      | 32-33       |
| 6        | 32        | 低      | 33-33       |
| 7        | 33        | 正确    |             |

只需7次就得到了正确答案。这是需要的最多次数。幸运的话你可能一次就能猜中，如数字是50。

## 3. 对数（Logarithm）

上述猜数字游戏中，100个数中最多只需7次就能找到目标。如果需要猜测的范围不是100呢？下图显示了一些具有代表性的取值范围和采用二分查找对应的比较次数。

表2

| 取值范围         | 所需比较次数 |
| ----------      | ----------- |
| 10              | 4           |
| 100             | 7           |
| 1,000           | 10          |
| 10,000          | 14          |
| 100,000         | 17          |
| 1,000,000       | 20          |
| 10,000,000      | 24          |
| 100,000,000     | 27          |
| 1,000,000,0000  | 30          |

### 3.1 等式

要验证上述表格，可以不断平分一个值，直到得到的结果小到不能再分为止。这一过程所需的平分次数，就是第二列中展示的比较次数。

把一个值不断除以2，就是找到比较次数的一种算法。你可能会想，是否能用一个简单的等式找到这个值。当然有这样的等式，并且值得去探索，因为在学习数据结构的过程中它会反复出现。

表2省略了一些有趣的数据。该表没有回答这样的问题：如果搜索5次，那么搜索范围的最大取值是多少？要解决这个问题，我们需要创建一个类似的表格，不过这个表格值域取值从1开始，逐次扩大，每次乘以2。

表3

| 次数s    | 值域r          | 记为2的幂指数形式的值域 |
| --------| -------------- | ------------------- |
| 0       | 1              | 2^0                 |
| 1       | 2              | 2^1                 |
| 2       | 4              | 2^2                 |
| 3       | 8              | 2^3                 |
| 4       | 16             | 2^4                 |
| 5       | 32             | 2^5                 |
| 6       | 64             | 2^6                 |
| 7       | 128            | 2^7                 |
| 8       | 256            | 2^8                 |
| 9       | 512            | 2^9                 |
| 10      | 1024           | 2^10                |

就最初取值100的问题而言，比较6次产生的值域不够大（64），7次（128）就足以包含100了。

每次值域翻番，等同于增加2的幂。我们可以把这个幂表述为一个公式。如果`s`代表次数（乘以2的次数），`r`代表值域，则有等式：

```
r = 2^s
```

知道次数`s`，则能知道值域`r`。

### 3.2 反转幂指数

我们最初的问题与上述描述相反：已知一个取值范围，需要多少次比较才能完成一次查找？即给定`r`，需要一个等式给出`s`。

一个数的幂指数，反过来称为对数。公式如下：

s = log<sub>2</sub>(r)

该等式表示，比较次数等于以2为底的值域的对数。什么是对数？一个数`r`以2为底的对数，就是为了得到`r`而需要2**乘以自己**的次数。

如何可以不做大量除法找出一个数的对数？便携计算器和多数编程语言都有对数函数。通常以10为底，不过很容易就能转成以2为底：乘以`3.322`即可。如，log<sub>10</sub>(100) = 2，则log<sub>2</sub>(100) = 2 * 3.322，即6.644，四舍五入得到7，这就是表2中100右侧的数字。

不过，这里的重点不是计算对数，而是理解一个数字及其对数之间的关系。再看一下表2中元素数量与找到某个元素所需次数之间的关系。每次元素数量翻10倍，找到某个特定元素只需要增加3到4次比较。这是因为，随着数字增大，该数字的对数增长并不快。

## 4. Big O 标记法

汽车按大小分为几类：微型、小型、中型等等。这些分类能让人迅速理解你所讨论的车的大小，不需要提及实际尺寸。同理，是不是可以有一种方法能够简明地表明一种算法的效率。在计算机科学中，这种粗略的衡量方式称为“Big O”标记法。

你可能会想，比较算法时可以说“算法A算法B快一倍”，但事实上，这种说法没有太大意义。为什么呢？因为随着元素的变化，这种比例会急剧变化。或许元素数量增加50%，算法A的速度就是B的三倍了。或者减少一半，算法A和算法B速度相同。我们需要一种比较方法，能够表明**算法速度**与**元素数量**之间的关系。我们看看几种简单算法中如何使用Big O。

### 4.1 无序数组中插入元素耗时：常量

向无序数组中插入元素不依赖数组中元素个数。新元素总是插入下一个可用的位置`a[nElems]`，然后`nElems`增加。不管N（数组中的元素数量）有多大，插入需要的时间相同。向无序数组中插入一个元素的时间`T`是常量`K`：

```
T = K
```

现实中，插入元素所需的实际时间与处理器速度、编译器生成的程序代码效率以及其他因素相关。常量`K`涵盖了这些因素。

### 4.2 线性查找：与N成比例

用线性查找搜索数组中的元素，找到一个元素，所必须比较的次数平均是元素总数的一半。因此，如果`N`表示元素总数，搜索时间`T`与`N`的一半成比例：

```
T = K * N / 2
```

方便起见，我们可以把`2`合并到`K`中，则得到：

```
T = K * N
```

该等式表明，线性查找的平均时间与数组的大小成比例。数组增加一倍，则查找时间增加一倍。

### 4.3 二分查找：与log(N)成比例

同样，我们可以为二分查找创造一个`T`与`Ｎ`的关系式：

```
T = K * log2(N)
```

时间与以2为底N的对数成比例。实际上，由于任何对数之间都存在常量关系（以2为底与以10为底之间是3.322），可以这个常量合并到`K`中：

```
T = K * log(N)
```

### 4.4 去掉常量

Big O标记法与上述公式形似，不过去掉了`K`。比较算法时，只需要比较T随N的变化即可，因此不需要常量K。

Big O标记法使用大写的字母O，可以把它看作“级数”（order of）之意。用这种方法，我们可以说，线性查找耗时`O(N)`，二分查找耗时`O(log N)`。无序数组插入元素耗时`O(1)`，即时间是常量。

Big O不是要给出具体的运行时间，而是表示随着元素数量变化，运行时间如何变化。
