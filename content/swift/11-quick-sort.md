---
title: "数据结构与算法(Swift):快速排序"
date: 2021-06-18T10:33:06+08:00
draft: true
---


快速排序(quicksort)无疑是最流行的排序算法，因为在多数情况下，快速排序最快，所需时间是O(N*logN)。（仅针对内部或者内存排序，在磁盘文件中对数据排序，其他算法肯能更快。）快速排序由查尔斯·安东尼·理查德·霍尔(Charles Antony Richard Hoare)于1962年发现。

注：C.A.R. Hoare，英国计算机科学家，图灵奖得主，也是null的创造者--他称之为价值数十亿的错误。

要理解快速排序，应该熟悉上一节讲述的分区算法。快速排序把一个数组分成两个子数组，然后递归地调用自己，快速排序每一个子数组。不过，这个基本的方案还有一些细节需要我们处理。这涉及到选择基准值以及各种小分区的排序。我们先看核心的算法，稍后再看这些改进。

## 快速排序算法

基本的递归快速排序相当简单，例如：

如你所见，分成三个基本步骤：

1. 数组或子数组分期，分成左右两组，左侧是较小的键，右侧是较大键。
2. 调用自身来给左侧组排序。
3. 调用自身被右侧组排序。

分区之后，左侧子数组的元素都比右侧的元素小。如果继续给左侧子数组和右侧子数组分别排序，整个数组就排好序了。那莪如何给这些子数组排序呢？递归地调用自身。

`recQuickSort()`的参数决定了所要排序的数组（或子数组）的左右边界。该方法首先检查这个数组是否只有一个元素。如果是，按照定义，这个数组已经排好顺序，立刻返回。这是此处递归的基准。

如果该数组由两个或多个元素，算法调用`partitionIt()`方法给数组分区。该方法返回分区的索引：右侧子数组的左侧元素。分区索引标明了子数组之间的分界线。

数组分区后，`recQuickSort()`调用自己，一次用于数组的左侧部分，索引从`left`到`partition-1`，一次用于数组的右侧部分，从`partition+1`到`right`。注意，在两次递归调用中，都没有包括`partition`索引的数据元素。为什么呢？这个元素不需要排序吗？原因取决于如何选择基准值。

## 选择基准值

`partitionIt()`方法应该用什么做基准值？可以参考如下要点：

* 基准值应该是实际存在的数据元素的键值，这个元素称为基准。
* 大致上可以随机选择一个数据元素做基准。简单起见，我们可以总是选择需要分期的子数据最右侧的元素。
* 执行分区以后，如果基准值插入的位置在左右两侧子数据之间，那就是它的最终位置。

最后一点可能听上去不可能，但记住，因为记基准值的键被用于分割数组，在分区之后，左侧子数组的所有元素都小于基准，右侧子数组的所有制都大于基准。基准值从右侧开始，但如果它被放在了连个子数组之间，那就在正确的位置--也就是说，在最终的排序位置上。下图展示了这一结果，选择的记住只是36.

该图不太现实，因为你实际上无法像图中所示那样切割一个数组。那么如何把基准移动到正确的位置呢？

我们可以把右侧子数组中的所有元素都向右移动一格，为基准值让出空间。但是，这么做效率低而且没有必要。右侧子数组的所有元素虽然比基准值大，但尚未排序，所以还会在右侧子数组内部继续移动，但不会有影响这个子数组之外的元素。因为，为了简化插入基准值到恰当的位置，我们可以直接把基准值（36）与右侧子数组的最左侧元素（63）交换。交换后，基准值就放在了左右两侧子数组之间的前挡位置。63放在了最右端，但因为它依然在右侧组，分期未受影响。如下图所示。

当基准值被换到了分区位置，就是它的最终静止位置了。接下来所有的操作都发生在他的左侧或者右侧，但基准值本身不会再移动（实际上不会再访问）。

采用选择最右侧元素作为基准值的方案时，需要修改`partitionIt()`方法，把最右侧的元素从分区中排除，因为我们已经知道了分区过程完成后基准值应该放在哪里：在两个子数组的分割位置。此外，再分区过程完成后，我们需要把基准值从右侧换到分割位置。

## Swift实现

有趣的一点是，`partitionIt()`方法中，在第一个内部while循环中，我们能够移除测试是否达到了子数组末尾。为什么呢？因为我们选择了最右侧的元素作为基准值，如果`leftIndex`达到了子数组的末尾，由于一个数不会比它自身小，肯定会停下来。不过第二个while中依然需要检测`rightIndex`移动到了数组的开始。

因此，使用最右侧元素作为基准值并非完全随意的选择，这么做移除了一个不必要的测试，加算了代码执行。从其他位置选择基准值不会提供这一优势。

## 性能下降到O(N²)

如果用快速排序给100个降序排列的元素排序，就会发现这个算法运行起来慢得多。

问题在于基准值的选择。理想情况下，基准值应该是被排序元素的中值。即，一般元素比基准值大，一般元素比基准值小。数组就会被分成两个相同大小的子数组。有两个相同长度的子数组，对快速排序算法来说时最理想的情况。如果子数组一个长一个短，效率就会变低，因为元素多的数组需要分割的次数更多。

最糟糕的情况时，一个N个元素构成的子数组，被分成了只有1个元素的和有N-1个元素的两个数组。如果每次分区都出现1个和N-1个子数组，每一个元素都需要一次单的的分区步骤。降序排列的数组就是这种情况：所有的子数组中，基准值都是最小的元素，所以每次分期都导致一个子数组中有N-1个元素，另一个子数组中只有基准值。

这种情况下，分区带来的优势就消失了，算法的性能降到O(N²)。

除了速度慢之外，排序算法耗时O(N²)时，还有一个潜在问题。当分期次数增加时，递归调用函数的次数也增加。每次函数调用都会占用机器的堆栈空间。如果调用过多，机器的堆栈会溢出，导致系统崩溃。

如果数据已经按照升序或者降序排好了，从数组一端选择基准值不好。如何改进基准值的选择呢？

## 三位中值分区

人们设计了很多方案来选择更好的基准值。方法应该简单，但要大概率避开选择最大值或者最小值。随机选择一个元素很简单，但正如我们所见，并不总能导致最好的选择。不过，我们可以检查所有的元素，计算哪个元素才是中值。这将是最理想的基准选择，但这个过程不显示，因为它所需时间比排序本身还长。

一个妥协的方案是找出数组中第一、最后和中间三个元素的中间值，选出第一、最后和中间元素的中间值叫做三位中值法(median-of-three)，如下图所示。

找出三个元素的中值显然比找出所有元素的中值快得多，在数组已经升序或降序排列的情况，能避免挑出最大值或最小值。可能有些异常奇怪的数据排列中，三位中值法表现糟糕，但正常情况下三位中值法能够快速有效地找出基准值。

除了更加有效地选出基准值，三位中值法还有一个额外的好处：能够略去第二个while循环中的条件检测`rightIndex > left`，从而略微加快算法的速度。这是怎么实现的？

能够消除这个检测，因为我们使用三位中值法不仅能够选出基准值，还能再选择的过程中对这三个元素排序。

这三个元素排好顺序后，中间的元素被选中作为基准值，我们就可以保证，子数组左端的元素小于（或等于）基准值，右端的元素大于（或等于）基准值。这意味着，索引`leftIndex`和`rightIndex`不会超出数组的左右边界。

三位中值法另外一个小小的好处是，在这三个值排序后，分区过程就不需要再检测这些元素了。分区能够从`left+1`和`right-1`开始，因为`left`和`right`已经分割完毕。我们知道`left`在正确的位置，因为它在左侧，比基准值小，`right`在右侧，比基准值大。

因此，三位中值法不仅避免了已排序数据性能降到O(N²)，还能让我们加快分割算法中内部循环的速度，减少必须分割的元素的数量。

